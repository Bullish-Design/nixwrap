"""Generator for package.nix files."""
from __future__ import annotations

from textwrap import dedent

from nix_devenv_wrapper.models import FlakeConfig, PackageRegistry


def generate_package_nix(config: FlakeConfig, version: str, sha256: str) -> str:
    """Generate a package.nix file for the given configuration."""
    if config.source.registry == PackageRegistry.NPM:
        return _generate_npm_package(config, version, sha256)
    if config.source.registry == PackageRegistry.PYPI:
        return _generate_pypi_package(config, version, sha256)
    if config.source.registry == PackageRegistry.GITHUB_RELEASE:
        return _generate_github_package(config, version, sha256)
    raise NotImplementedError(f"Registry {config.source.registry} not yet supported")


def _generate_npm_package(config: FlakeConfig, version: str, sha256: str) -> str:
    """Generate package.nix for an npm package."""
    package_name = config.source.name
    runtime_pkg = config.runtime.nix_package
    binary_name = config.wrapper.binary_name
    entry_point = config.wrapper.entry_point

    if package_name.startswith("@"): 
        scope, name = package_name.split("/", 1)
        tarball_url = f"https://registry.npmjs.org/{scope}/{name}/-/{name}-${{version}}.tgz"
        module_path = f"$out/lib/node_modules/{package_name}"
    else:
        tarball_url = f"https://registry.npmjs.org/{package_name}/-/{package_name}-${{version}}.tgz"
        module_path = f"$out/lib/node_modules/{package_name}"

    env_exports = []
    if config.wrapper.disable_auto_update:
        env_exports.append('export DISABLE_AUTOUPDATER=1')
    for key, value in config.wrapper.env_vars.items():
        env_exports.append(f'export {key}="{value}"')
    env_section = "\n            ".join(env_exports) if env_exports else ""

    node_flags = " ".join(config.wrapper.node_flags) if config.wrapper.node_flags else ""
    node_flags_arg = f" {node_flags}" if node_flags else ""

    return dedent(
        f"""\
        # {config.pname} package - auto-generated by nix-devenv-wrapper
        {{ lib
        , stdenv
        , fetchurl
        , {runtime_pkg}
        , cacert
        , bash
        }}:

        let
          version = "{version}";

          tarball = fetchurl {{
            url = "{tarball_url}";
            sha256 = "{sha256}";
          }};
        in
        stdenv.mkDerivation rec {{
          pname = "{config.pname}";
          inherit version;

          dontUnpack = true;

          nativeBuildInputs = [
            {runtime_pkg}
            cacert
          ];

          buildPhase = ''
            export HOME=$TMPDIR
            mkdir -p $HOME/.npm

            export SSL_CERT_FILE=${{cacert}}/etc/ssl/certs/ca-bundle.crt
            export NODE_EXTRA_CA_CERTS=$SSL_CERT_FILE

            ${{{runtime_pkg}}}/bin/npm config set cafile $SSL_CERT_FILE
            ${{{runtime_pkg}}}/bin/npm config set offline true
            ${{{runtime_pkg}}}/bin/npm install -g --prefix=$out ${{tarball}}
          '';

          installPhase = ''
            rm -f $out/bin/{binary_name}

            mkdir -p $out/bin
            cat > $out/bin/{binary_name} << 'EOF'
            #!${{bash}}/bin/bash
            export NODE_PATH="{module_path}"
            {env_section}
            exec ${{{runtime_pkg}}}/bin/node{node_flags_arg} "{module_path}/{entry_point}" "$@"
        EOF
            chmod +x $out/bin/{binary_name}

            substituteInPlace $out/bin/{binary_name} \
              --replace '{module_path}' "$out/lib/node_modules/{package_name}"
          '';

          meta = with lib; {{
            description = "{config.meta.description}";
            homepage = "{config.meta.homepage}";
            license = licenses.{config.meta.license};
            platforms = {config.meta.platforms};
            mainProgram = "{config.meta.main_program or binary_name}";
          }};
        }}
        """
    )


def _generate_pypi_package(config: FlakeConfig, version: str, sha256: str) -> str:
    """Generate package.nix for a PyPI package."""
    package_name = config.source.name
    runtime_pkg = config.runtime.nix_package
    binary_name = config.wrapper.binary_name

    return dedent(
        f"""\
        # {config.pname} package - auto-generated by nix-devenv-wrapper
        {{ lib
        , {runtime_pkg}
        , fetchPypi
        }}:

        {runtime_pkg}.pkgs.buildPythonApplication rec {{
          pname = "{config.pname}";
          version = "{version}";

          src = fetchPypi {{
            inherit pname version;
            sha256 = "{sha256}";
          }};

          meta = with lib; {{
            description = "{config.meta.description}";
            homepage = "{config.meta.homepage}";
            license = licenses.{config.meta.license};
            platforms = {config.meta.platforms};
            mainProgram = "{config.meta.main_program or binary_name}";
          }};
        }}
        """
    )


def _generate_github_package(config: FlakeConfig, version: str, sha256: str) -> str:
    """Generate package.nix for a GitHub release."""
    package_name = config.source.name  # Format: owner/repo
    owner, repo = package_name.split("/")
    binary_name = config.wrapper.binary_name
    entry_point = config.wrapper.entry_point
    runtime_type = config.runtime.runtime_type.value

    # Determine the tag format (try with 'v' prefix)
    tag = f"v{version}" if not version.startswith("v") else version

    # Build dependencies based on runtime type
    build_inputs = []
    if config.runtime.extra_packages:
        build_inputs.extend(config.runtime.extra_packages)

    build_inputs_str = "\n    ".join(build_inputs) if build_inputs else ""
    build_inputs_section = f"""
  buildInputs = [
    {build_inputs_str}
  ];
""" if build_inputs else ""

    # Environment variable exports
    env_exports = []
    if config.wrapper.disable_auto_update:
        env_exports.append('export DISABLE_AUTOUPDATER=1')
    for key, value in config.wrapper.env_vars.items():
        env_exports.append(f'export {key}="{value}"')
    env_section = "\n            ".join(env_exports) if env_exports else ""

    # Runtime-specific wrapper
    runtime_pkg = config.runtime.nix_package
    if runtime_type == "nodejs":
        node_flags = " ".join(config.wrapper.node_flags) if config.wrapper.node_flags else ""
        node_flags_arg = f" {node_flags}" if node_flags else ""
        wrapper_exec = f'exec ${{{runtime_pkg}}}/bin/node{node_flags_arg} "$out/{entry_point}" "$@"'
        runtime_input = runtime_pkg
    elif runtime_type == "python":
        wrapper_exec = f'exec ${{{runtime_pkg}}}/bin/python "$out/{entry_point}" "$@"'
        runtime_input = runtime_pkg
    else:
        # For compiled binaries or no runtime
        wrapper_exec = f'exec "$out/{entry_point}" "$@"'
        runtime_input = None

    runtime_section = f"\n  , {runtime_input}" if runtime_input else ""

    return dedent(
        f"""\
        # {config.pname} package - auto-generated by nix-devenv-wrapper
        {{ lib
        , stdenv
        , fetchFromGitHub
        , bash{runtime_section}
        }}:

        stdenv.mkDerivation rec {{
          pname = "{config.pname}";
          version = "{version}";

          src = fetchFromGitHub {{
            owner = "{owner}";
            repo = "{repo}";
            rev = "{tag}";
            sha256 = "{sha256}";
          }};
{build_inputs_section}
          installPhase = ''
            mkdir -p $out/bin
            cp -r . $out/

            cat > $out/bin/{binary_name} << 'EOF'
            #!${{bash}}/bin/bash
            {env_section}
            {wrapper_exec}
        EOF
            chmod +x $out/bin/{binary_name}
          '';

          meta = with lib; {{
            description = "{config.meta.description}";
            homepage = "{config.meta.homepage}";
            license = licenses.{config.meta.license};
            platforms = {config.meta.platforms};
            mainProgram = "{config.meta.main_program or binary_name}";
          }};
        }}
        """
    )
